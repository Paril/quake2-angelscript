namespace soldier
{
    enum frames {
        attak101,
        attak102,
        attak103,
        attak104,
        attak105,
        attak106,
        attak107,
        attak108,
        attak109,
        attak110,
        attak111,
        attak112,
        attak201,
        attak202,
        attak203,
        attak204,
        attak205,
        attak206,
        attak207,
        attak208,
        attak209,
        attak210,
        attak211,
        attak212,
        attak213,
        attak214,
        attak215,
        attak216,
        attak217,
        attak218,
        attak301,
        attak302,
        attak303,
        attak304,
        attak305,
        attak306,
        attak307,
        attak308,
        attak309,
        attak401,
        attak402,
        attak403,
        attak404,
        attak405,
        attak406,
        duck01,
        duck02,
        duck03,
        duck04,
        duck05,
        pain101,
        pain102,
        pain103,
        pain104,
        pain105,
        pain201,
        pain202,
        pain203,
        pain204,
        pain205,
        pain206,
        pain207,
        pain301,
        pain302,
        pain303,
        pain304,
        pain305,
        pain306,
        pain307,
        pain308,
        pain309,
        pain310,
        pain311,
        pain312,
        pain313,
        pain314,
        pain315,
        pain316,
        pain317,
        pain318,
        pain401,
        pain402,
        pain403,
        pain404,
        pain405,
        pain406,
        pain407,
        pain408,
        pain409,
        pain410,
        pain411,
        pain412,
        pain413,
        pain414,
        pain415,
        pain416,
        pain417,
        run01,
        run02,
        run03,
        run04,
        run05,
        run06,
        run07,
        run08,
        run09,
        run10,
        run11,
        run12,
        runs01,
        runs02,
        runs03,
        runs04,
        runs05,
        runs06,
        runs07,
        runs08,
        runs09,
        runs10,
        runs11,
        runs12,
        runs13,
        runs14,
        runs15,
        runs16,
        runs17,
        runs18,
        runt01,
        runt02,
        runt03,
        runt04,
        runt05,
        runt06,
        runt07,
        runt08,
        runt09,
        runt10,
        runt11,
        runt12,
        runt13,
        runt14,
        runt15,
        runt16,
        runt17,
        runt18,
        runt19,
        stand101,
        stand102,
        stand103,
        stand104,
        stand105,
        stand106,
        stand107,
        stand108,
        stand109,
        stand110,
        stand111,
        stand112,
        stand113,
        stand114,
        stand115,
        stand116,
        stand117,
        stand118,
        stand119,
        stand120,
        stand121,
        stand122,
        stand123,
        stand124,
        stand125,
        stand126,
        stand127,
        stand128,
        stand129,
        stand130,
        stand301,
        stand302,
        stand303,
        stand304,
        stand305,
        stand306,
        stand307,
        stand308,
        stand309,
        stand310,
        stand311,
        stand312,
        stand313,
        stand314,
        stand315,
        stand316,
        stand317,
        stand318,
        stand319,
        stand320,
        stand321,
        stand322,
        stand323,
        stand324,
        stand325,
        stand326,
        stand327,
        stand328,
        stand329,
        stand330,
        stand331,
        stand332,
        stand333,
        stand334,
        stand335,
        stand336,
        stand337,
        stand338,
        stand339,
        walk101,
        walk102,
        walk103,
        walk104,
        walk105,
        walk106,
        walk107,
        walk108,
        walk109,
        walk110,
        walk111,
        walk112,
        walk113,
        walk114,
        walk115,
        walk116,
        walk117,
        walk118,
        walk119,
        walk120,
        walk121,
        walk122,
        walk123,
        walk124,
        walk125,
        walk126,
        walk127,
        walk128,
        walk129,
        walk130,
        walk131,
        walk132,
        walk133,
        walk201,
        walk202,
        walk203,
        walk204,
        walk205,
        walk206,
        walk207,
        walk208,
        walk209,
        walk210,
        walk211,
        walk212,
        walk213,
        walk214,
        walk215,
        walk216,
        walk217,
        walk218,
        walk219,
        walk220,
        walk221,
        walk222,
        walk223,
        walk224,
        death101,
        death102,
        death103,
        death104,
        death105,
        death106,
        death107,
        death108,
        death109,
        death110,
        death111,
        death112,
        death113,
        death114,
        death115,
        death116,
        death117,
        death118,
        death119,
        death120,
        death121,
        death122,
        death123,
        death124,
        death125,
        death126,
        death127,
        death128,
        death129,
        death130,
        death131,
        death132,
        death133,
        death134,
        death135,
        death136,
        death201,
        death202,
        death203,
        death204,
        death205,
        death206,
        death207,
        death208,
        death209,
        death210,
        death211,
        death212,
        death213,
        death214,
        death215,
        death216,
        death217,
        death218,
        death219,
        death220,
        death221,
        death222,
        death223,
        death224,
        death225,
        death226,
        death227,
        death228,
        death229,
        death230,
        death231,
        death232,
        death233,
        death234,
        death235,
        death301,
        death302,
        death303,
        death304,
        death305,
        death306,
        death307,
        death308,
        death309,
        death310,
        death311,
        death312,
        death313,
        death314,
        death315,
        death316,
        death317,
        death318,
        death319,
        death320,
        death321,
        death322,
        death323,
        death324,
        death325,
        death326,
        death327,
        death328,
        death329,
        death330,
        death331,
        death332,
        death333,
        death334,
        death335,
        death336,
        death337,
        death338,
        death339,
        death340,
        death341,
        death342,
        death343,
        death344,
        death345,
        death401,
        death402,
        death403,
        death404,
        death405,
        death406,
        death407,
        death408,
        death409,
        death410,
        death411,
        death412,
        death413,
        death414,
        death415,
        death416,
        death417,
        death418,
        death419,
        death420,
        death421,
        death422,
        death423,
        death424,
        death425,
        death426,
        death427,
        death428,
        death429,
        death430,
        death431,
        death432,
        death433,
        death434,
        death435,
        death436,
        death437,
        death438,
        death439,
        death440,
        death441,
        death442,
        death443,
        death444,
        death445,
        death446,
        death447,
        death448,
        death449,
        death450,
        death451,
        death452,
        death453,
        death501,
        death502,
        death503,
        death504,
        death505,
        death506,
        death507,
        death508,
        death509,
        death510,
        death511,
        death512,
        death513,
        death514,
        death515,
        death516,
        death517,
        death518,
        death519,
        death520,
        death521,
        death522,
        death523,
        death524,
        death601,
        death602,
        death603,
        death604,
        death605,
        death606,
        death607,
        death608,
        death609,
        death610,
        stand401,
        stand402,
        stand403,
        stand404,
        stand405,
        stand406,
        stand407,
        stand408,
        stand409,
        stand410,
        stand411,
        stand412,
        stand413,
        stand414,
        stand415,
        stand416,
        stand417,
        stand418,
        stand419,
        stand420,
        stand421,
        stand422,
        stand423,
        stand424,
        stand425,
        stand426,
        stand427,
        stand428,
        stand429,
        stand430,
        stand431,
        stand432,
        stand433,
        stand434,
        stand435,
        stand436,
        stand437,
        stand438,
        stand439,
        stand440,
        stand441,
        stand442,
        stand443,
        stand444,
        stand445,
        stand446,
        stand447,
        stand448,
        stand449,
        stand450,
        stand451,
        stand452,
        stand201,
        stand202,
        stand203,
        stand204,
        stand205,
        stand206,
        stand207,
        stand208,
        stand209,
        stand210,
        stand211,
        stand212,
        stand213,
        stand214,
        stand215,
        stand216,
        stand217,
        stand218,
        stand219,
        stand220,
        stand221,
        stand222,
        stand223,
        stand224,
        stand225,
        stand226,
        stand227,
        stand228,
        stand229,
        stand230,
        stand231,
        stand232,
        stand233,
        stand234,
        stand235,
        stand236,
        stand237,
        stand238,
        stand239,
        stand240,
        attak501,
        attak502,
        attak503,
        attak504,
        attak505,
        attak506,
        attak507,
        attak508
    };

    const float SCALE		= 1.2f;
}

namespace soldier::sounds
{
    cached_soundindex idle("soldier/solidle1.wav");
    cached_soundindex sight1("soldier/solsght1.wav");
    cached_soundindex sight2("soldier/solsrch1.wav");
    cached_soundindex cock("infantry/infatck3.wav");
    cached_soundindex pain_light("soldier/solpain2.wav");
    cached_soundindex death_light("soldier/soldeth2.wav");
    cached_soundindex pain("soldier/solpain1.wav");
    cached_soundindex death("soldier/soldeth1.wav");
    cached_soundindex pain_ss("soldier/solpain3.wav");
    cached_soundindex death_ss("soldier/soldeth3.wav");
}

enum soldier_weapon_t
{
    Blaster,
    Shotgun,
    Machinegun,
    Ripper,
    BlueHyper,
    Laser
};

class soldier_style_t
{
	soldier_weapon_t weapon;

	soldier_style_t(ASEntity &self)
	{
        this.weapon = soldier_weapon_t((self.count / 2) + (self.style * 3));
	}
	
	// is ripper, bluehyper or laser
	const bool is_xatrix() const { return weapon >= soldier_weapon_t::Ripper; }
	// is blaster, shotgun or machinegun
	const bool is_vanilla() const { return weapon < soldier_weapon_t::Ripper; }
	 
	// is blaster or ripper
	const bool is_light() const { return weapon == soldier_weapon_t::Blaster || weapon == soldier_weapon_t::Ripper; }
	// is shotgun or bluehyper
	const bool is_blitz() const { return weapon == soldier_weapon_t::Shotgun || weapon == soldier_weapon_t::BlueHyper; }
	// is machinegun or laser
	const bool is_sustain() const { return weapon == soldier_weapon_t::Machinegun || weapon == soldier_weapon_t::Laser; }
	
	const bool has_blaster() { return weapon == soldier_weapon_t::Blaster; }
	const bool has_shotgun() { return weapon == soldier_weapon_t::Shotgun; }
	const bool has_machinegun() { return weapon == soldier_weapon_t::Machinegun; }
	const bool has_ripper() { return weapon == soldier_weapon_t::Ripper; }
	const bool has_bluehyper() { return weapon == soldier_weapon_t::BlueHyper; }
	const bool has_laser() { return weapon == soldier_weapon_t::Laser; }
};

void soldier_start_charge(ASEntity &self)
{
	self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::CHARGING);
}

void soldier_stop_charge(ASEntity &self)
{
	self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::CHARGING);
}

void soldier_idle(ASEntity &self)
{
	if (frandom() > 0.8f)
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::idle, 1, ATTN_IDLE, 0);
}

void soldier_cock(ASEntity &self)
{
	if (self.e.s.frame == soldier::frames::stand322)
		gi_sound(self.e, soundchan_t::WEAPON, soldier::sounds::cock, 1, ATTN_IDLE, 0);
	else
		gi_sound(self.e, soundchan_t::WEAPON, soldier::sounds::cock, 1, ATTN_NORM, 0);

	// [Paril-KEX] reset cockness
	self.dmg = 0;
}

// RAFAEL
void soldierh_hyper_sound_start(ASEntity &self)
{
	if (soldier_style_t(self).has_bluehyper())
		self.monsterinfo.weapon_sound = gi_soundindex("weapons/hyprbl1a.wav");
}

void soldierh_hyper_sound_end(ASEntity &self)
{
	if (self.monsterinfo.weapon_sound != 0)
	{
		if (soldier_style_t(self).has_bluehyper())
			gi_sound(self.e, soundchan_t::AUTO, gi_soundindex("weapons/hyprbd1a.wav"), 1, ATTN_NORM, 0);

		self.monsterinfo.weapon_sound = 0;
	}
}
// RAFAEL

// STAND

const array<mframe_t> soldier_frames_stand1 = {
	mframe_t(ai_stand, 0, soldier_idle),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand)
};
const mmove_t soldier_move_stand1 = mmove_t(soldier::frames::stand101, soldier::frames::stand130, soldier_frames_stand1, soldier_stand);

const array<mframe_t> soldier_frames_stand2 = {
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand, 0, monster_footstep),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand, 0, monster_footstep)
};
const mmove_t soldier_move_stand2 = mmove_t(soldier::frames::stand201, soldier::frames::stand240, soldier_frames_stand2, soldier_stand);

const array<mframe_t> soldier_frames_stand3 = {
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand, 0, soldier_cock),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),

	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand),
	mframe_t(ai_stand)
};
const mmove_t soldier_move_stand3 = mmove_t(soldier::frames::stand301, soldier::frames::stand339, soldier_frames_stand3, soldier_stand);

void soldier_stand(ASEntity &self)
{
	float r = frandom();

	if ((self.monsterinfo.active_move !is soldier_move_stand1) || (r < 0.6f))
		M_SetAnimation(self, soldier_move_stand1);
	else if (r < 0.8f)
		M_SetAnimation(self, soldier_move_stand2);
	else
		M_SetAnimation(self, soldier_move_stand3);
	soldierh_hyper_sound_end(self);
}

//
// WALK
//

void soldier_walk1_random(ASEntity &self)
{
	if (frandom() > 0.1f)
		self.monsterinfo.nextframe = soldier::frames::walk101;
}

const array<mframe_t> soldier_frames_walk1 = {
	mframe_t(ai_walk, 3),
	mframe_t(ai_walk, 6),
	mframe_t(ai_walk, 2),
	mframe_t(ai_walk, 2, monster_footstep),
	mframe_t(ai_walk, 2),
	mframe_t(ai_walk, 1),
	mframe_t(ai_walk, 6),
	mframe_t(ai_walk, 5),
	mframe_t(ai_walk, 3, monster_footstep),
	mframe_t(ai_walk, -1, soldier_walk1_random),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk),
	mframe_t(ai_walk)
};
const mmove_t soldier_move_walk1 = mmove_t(soldier::frames::walk101, soldier::frames::walk133, soldier_frames_walk1, null);

const array<mframe_t> soldier_frames_walk2 = {
	mframe_t(ai_walk, 4, monster_footstep),
	mframe_t(ai_walk, 4),
	mframe_t(ai_walk, 9),
	mframe_t(ai_walk, 8),
	mframe_t(ai_walk, 5),
	mframe_t(ai_walk, 1, monster_footstep),
	mframe_t(ai_walk, 3),
	mframe_t(ai_walk, 7),
	mframe_t(ai_walk, 6),
	mframe_t(ai_walk, 7)
};
const mmove_t soldier_move_walk2 = mmove_t(soldier::frames::walk209, soldier::frames::walk218, soldier_frames_walk2, null);

void soldier_walk(ASEntity &self)
{
	// [Paril-KEX] during N64 cutscene, always use fast walk or we bog down the line
	if ((self.hackflags & HACKFLAG_END_CUTSCENE) == 0 && frandom() < 0.5f)
		M_SetAnimation(self, soldier_move_walk1);
	else
		M_SetAnimation(self, soldier_move_walk2);
}

//
// RUN
//

const array<mframe_t> soldier_frames_start_run = {
	mframe_t(ai_run, 7),
	mframe_t(ai_run, 5)
};
const mmove_t soldier_move_start_run = mmove_t(soldier::frames::run01, soldier::frames::run02, soldier_frames_start_run, soldier_run);

const array<mframe_t> soldier_frames_run = {
	mframe_t(ai_run, 10),
	mframe_t(ai_run, 11, function(self) { monster_done_dodge(self); monster_footstep(self); }),
	mframe_t(ai_run, 11),
	mframe_t(ai_run, 16),
	mframe_t(ai_run, 10, monster_footstep),
	mframe_t(ai_run, 15, monster_done_dodge)
};
const mmove_t soldier_move_run = mmove_t(soldier::frames::run03, soldier::frames::run08, soldier_frames_run, null);

void soldier_run(ASEntity &self)
{
	monster_done_dodge(self);
	soldierh_hyper_sound_end(self);

	if ((self.monsterinfo.aiflags & ai_flags_t::STAND_GROUND) != 0)
	{
		M_SetAnimation(self, soldier_move_stand1);
		return;
	}

	if (self.monsterinfo.active_move is soldier_move_walk1 ||
		self.monsterinfo.active_move is soldier_move_walk2 ||
		self.monsterinfo.active_move is soldier_move_start_run ||
		self.monsterinfo.active_move is soldier_move_run)
	{
		M_SetAnimation(self, soldier_move_run);
	}
	else
	{
		M_SetAnimation(self, soldier_move_start_run);
	}
}

//
// PAIN
//

const array<mframe_t> soldier_frames_pain1 = {
	mframe_t(ai_move, -3),
	mframe_t(ai_move, 4),
	mframe_t(ai_move, 1),
	mframe_t(ai_move, 1),
	mframe_t(ai_move)
};
const mmove_t soldier_move_pain1 = mmove_t(soldier::frames::pain101, soldier::frames::pain105, soldier_frames_pain1, soldier_run);

const array<mframe_t> soldier_frames_pain2 = {
	mframe_t(ai_move, -13),
	mframe_t(ai_move, -1),
	mframe_t(ai_move, 2),
	mframe_t(ai_move, 4),
	mframe_t(ai_move, 2),
	mframe_t(ai_move, 3),
	mframe_t(ai_move, 2)
};
const mmove_t soldier_move_pain2 = mmove_t(soldier::frames::pain201, soldier::frames::pain207, soldier_frames_pain2, soldier_run);

const array<mframe_t> soldier_frames_pain3 = {
	mframe_t(ai_move, -8),
	mframe_t(ai_move, 10),
	mframe_t(ai_move, -4, monster_footstep),
	mframe_t(ai_move, -1),
	mframe_t(ai_move, -3),
	mframe_t(ai_move),
	mframe_t(ai_move, 3),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, 1),
	mframe_t(ai_move),
	mframe_t(ai_move, 1),
	mframe_t(ai_move, 2),
	mframe_t(ai_move, 4),
	mframe_t(ai_move, 3),
	mframe_t(ai_move, 2, monster_footstep)
};
const mmove_t soldier_move_pain3 = mmove_t(soldier::frames::pain301, soldier::frames::pain318, soldier_frames_pain3, soldier_run);

const array<mframe_t> soldier_frames_pain4 = {
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, -10),
	mframe_t(ai_move, -6),
	mframe_t(ai_move, 8),
	mframe_t(ai_move, 4),
	mframe_t(ai_move, 1),
	mframe_t(ai_move),
	mframe_t(ai_move, 2),
	mframe_t(ai_move, 5),
	mframe_t(ai_move, 2),
	mframe_t(ai_move, -1),
	mframe_t(ai_move, -1),
	mframe_t(ai_move, 3),
	mframe_t(ai_move, 2),
	mframe_t(ai_move)
};
const mmove_t soldier_move_pain4 = mmove_t(soldier::frames::pain401, soldier::frames::pain417, soldier_frames_pain4, soldier_run);

void soldier_pain(ASEntity &self, ASEntity &other, float kick, int damage, const mod_t &in mod)
{
	float r;

	monster_done_dodge(self);
	soldier_stop_charge(self);

	// if we're blind firing, this needs to be turned off here
	self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::MANUAL_STEERING);

	if (level.time < self.pain_debounce_time)
	{
		if ((self.velocity[2] > 100) && ((self.monsterinfo.active_move is soldier_move_pain1) || (self.monsterinfo.active_move is soldier_move_pain2) || (self.monsterinfo.active_move is soldier_move_pain3)))
		{
			// PMM - clear duck flag
			if ((self.monsterinfo.aiflags & ai_flags_t::DUCKED) != 0)
				monster_duck_up(self);
			M_SetAnimation(self, soldier_move_pain4);
			soldierh_hyper_sound_end(self);
		}
		return;
	}

	self.pain_debounce_time = level.time + time_sec(3);

	soldier_style_t style(self);

	if (style.is_light())
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::pain_light, 1, ATTN_NORM, 0);
	else if (style.is_blitz())
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::pain, 1, ATTN_NORM, 0);
	else
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::pain_ss, 1, ATTN_NORM, 0);

	if (self.velocity[2] > 100)
	{
		// PMM - clear duck flag
		if ((self.monsterinfo.aiflags & ai_flags_t::DUCKED) != 0)
			monster_duck_up(self);
		M_SetAnimation(self, soldier_move_pain4);
		soldierh_hyper_sound_end(self);
		return;
	}
	
	if (!M_ShouldReactToPain(self, mod))
		return; // no pain anims in nightmare

	r = frandom();

	if (r < 0.33f)
		M_SetAnimation(self, soldier_move_pain1);
	else if (r < 0.66f)
		M_SetAnimation(self, soldier_move_pain2);
	else
		M_SetAnimation(self, soldier_move_pain3);

	// PMM - clear duck flag
	if ((self.monsterinfo.aiflags & ai_flags_t::DUCKED) != 0)
		monster_duck_up(self);
	soldierh_hyper_sound_end(self);
}

void soldier_setskin(ASEntity &self)
{
	if (self.health < (self.max_health / 2))
		self.e.s.skinnum |= 1;
	else
		self.e.s.skinnum &= ~1;
}

//
// ATTACK
//

const array<monster_muzzle_t> soldier_blaster_flash = { monster_muzzle_t::SOLDIER_BLASTER_1, monster_muzzle_t::SOLDIER_BLASTER_2, monster_muzzle_t::SOLDIER_BLASTER_3, monster_muzzle_t::SOLDIER_BLASTER_4, monster_muzzle_t::SOLDIER_BLASTER_5, monster_muzzle_t::SOLDIER_BLASTER_6, monster_muzzle_t::SOLDIER_BLASTER_7, monster_muzzle_t::SOLDIER_BLASTER_8, monster_muzzle_t::SOLDIER_BLASTER_9 };
const array<monster_muzzle_t> soldier_shotgun_flash = { monster_muzzle_t::SOLDIER_SHOTGUN_1, monster_muzzle_t::SOLDIER_SHOTGUN_2, monster_muzzle_t::SOLDIER_SHOTGUN_3, monster_muzzle_t::SOLDIER_SHOTGUN_4, monster_muzzle_t::SOLDIER_SHOTGUN_5, monster_muzzle_t::SOLDIER_SHOTGUN_6, monster_muzzle_t::SOLDIER_SHOTGUN_7, monster_muzzle_t::SOLDIER_SHOTGUN_8, monster_muzzle_t::SOLDIER_SHOTGUN_9 };
const array<monster_muzzle_t> soldier_machinegun_flash = { monster_muzzle_t::SOLDIER_MACHINEGUN_1, monster_muzzle_t::SOLDIER_MACHINEGUN_2, monster_muzzle_t::SOLDIER_MACHINEGUN_3, monster_muzzle_t::SOLDIER_MACHINEGUN_4, monster_muzzle_t::SOLDIER_MACHINEGUN_5, monster_muzzle_t::SOLDIER_MACHINEGUN_6, monster_muzzle_t::SOLDIER_MACHINEGUN_7, monster_muzzle_t::SOLDIER_MACHINEGUN_8, monster_muzzle_t::SOLDIER_MACHINEGUN_9 };

void soldierh_laser_update(ASEntity &laser)
{
	ASEntity @self = laser.owner;

	vec3_t forward, right, up;
	vec3_t start;
	vec3_t tempvec;

	AngleVectors(self.e.s.angles, forward, right, up);
	start = self.e.s.origin;
	tempvec = monster_flash_offset[self.radius_dmg];
	start += (forward * tempvec.x);
	start += (right * tempvec.y);
	start += (up * (tempvec.z + 6));

    vec3_t aimpoint; // AS_TODO

	if (!self.deadflag)
		PredictAim(self, self.enemy, start, 0, false, frandom(0.1f, 0.2f), forward, aimpoint);
	
	laser.e.s.origin = start;
	laser.movedir = forward;
	gi_linkentity(laser.e);
	dabeam_update(laser, false);
}

// RAFAEL
void soldierh_laserbeam(ASEntity &self, int flash_index)
{
	self.radius_dmg = flash_index;
	monster_fire_dabeam(self, 1, false, soldierh_laser_update);
}

const array<monster_muzzle_t> soldier_ripper_flash = { monster_muzzle_t::SOLDIER_RIPPER_1, monster_muzzle_t::SOLDIER_RIPPER_2, monster_muzzle_t::SOLDIER_RIPPER_3, monster_muzzle_t::SOLDIER_RIPPER_4, monster_muzzle_t::SOLDIER_RIPPER_5, monster_muzzle_t::SOLDIER_RIPPER_6, monster_muzzle_t::SOLDIER_RIPPER_7, monster_muzzle_t::SOLDIER_RIPPER_8, monster_muzzle_t::SOLDIER_RIPPER_9 };
const array<monster_muzzle_t> soldier_hyper_flash = { monster_muzzle_t::SOLDIER_HYPERGUN_1, monster_muzzle_t::SOLDIER_HYPERGUN_2, monster_muzzle_t::SOLDIER_HYPERGUN_3, monster_muzzle_t::SOLDIER_HYPERGUN_4, monster_muzzle_t::SOLDIER_HYPERGUN_5, monster_muzzle_t::SOLDIER_HYPERGUN_6, monster_muzzle_t::SOLDIER_HYPERGUN_7, monster_muzzle_t::SOLDIER_HYPERGUN_8, monster_muzzle_t::SOLDIER_HYPERGUN_9 };

void soldier_fire(ASEntity &self, int flash_number, bool angle_limited)
{
	vec3_t					 start;
	vec3_t					 forward, right, up;
	vec3_t					 aim;
	vec3_t					 dir;
	vec3_t					 end;
	float					 r, u;
	monster_muzzle_t flash_index;
	vec3_t					 aim_norm;
	float					 angle;
	vec3_t					 aim_good;

	soldier_style_t style(self);

	if (style.has_blaster())
		flash_index = soldier_blaster_flash[flash_number];
	else if (style.has_shotgun())
		flash_index = soldier_shotgun_flash[flash_number];
	else if (style.has_ripper())
		flash_index = soldier_ripper_flash[flash_number];
	else if (style.has_bluehyper())
		flash_index = soldier_hyper_flash[flash_number];
	else
		flash_index = soldier_machinegun_flash[flash_number];

	AngleVectors(self.e.s.angles, forward, right);
	start = M_ProjectFlashSource(self, monster_flash_offset[flash_index], forward, right);

	if (flash_number == 5 || flash_number == 6) // he's dead
	{
		if ((self.spawnflags & spawnflags::monsters::DEAD) != 0)
			return;

		aim = forward;
	}
	else
	{
		// [Paril-KEX] no enemy = no fire
		if ((self.enemy is null) || (!self.enemy.e.inuse))
		{
			self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::HOLD_FRAME);
			return;
		}

		// PMM
		if ((self.monsterinfo.aiflags & ai_flags_t::MANUAL_STEERING) != 0)
			end = self.monsterinfo.blind_fire_target;
		else
			end = self.enemy.e.s.origin;
		// pmm
		end[2] += self.enemy.viewheight;

		aim = end - start;
		aim_good = end;

		if ((self.monsterinfo.aiflags & ai_flags_t::MANUAL_STEERING) != 0)
			M_AdjustBlindfireTarget(self, start, end, right, dir);

		// PMM
		if (angle_limited)
		{
			aim_norm = aim;
			aim_norm.normalize();
			angle = aim_norm.dot(forward);
			
			if (angle < 0.5f) // ~25 degree angle
			{
				if (level.time >= self.monsterinfo.fire_wait)
					self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::HOLD_FRAME);
				else
					self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags | ai_flags_t::HOLD_FRAME);

				return;
			}
		}
		//-PMM

		dir = vectoangles(aim);
		AngleVectors(dir, forward, right, up);

		r = crandom() * 1000;
		u = crandom() * 500;
		
		if (style.is_xatrix())
		{
			r /= 10;
			u /= 10;
		}
		end = start + (forward * 8192);
		end += (right * r);
		end += (up * u);

		aim = end - start;
		aim.normalize();
	}

	if (style.has_ripper())
	{
		// RAFAEL 24-APR-98
		// droped the damage from 15 to 5
		monster_fire_ionripper(self, start, aim, 5, 600, flash_index, effects_t::IONRIPPER);
	}
	else if (style.has_bluehyper())
	{
		monster_fire_blueblaster(self, start, aim, 1, 600, flash_index, effects_t::BLUEHYPERBLASTER);
	}
	else if (style.has_blaster())
	{
		monster_fire_blaster(self, start, aim, 5, 600, flash_index, effects_t::BLASTER);
	}
	else if (style.has_shotgun())
	{
		monster_fire_shotgun(self, start, aim, 2, 1, 1500, 750, 9, flash_index);
		// [Paril-KEX] indicates to soldier that he must cock
		self.dmg = 1;
	}
	else
	{
		// PMM - changed to wait from pausetime to not interfere with dodge code
		if ((self.monsterinfo.aiflags & ai_flags_t::HOLD_FRAME) == 0)
			self.monsterinfo.fire_wait = level.time + random_time(time_ms(300), time_sec(1.1));

		if (style.has_laser())
			soldierh_laserbeam(self, flash_index);
		else
			monster_fire_bullet(self, start, aim, 2, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_index);

		if (level.time >= self.monsterinfo.fire_wait)
		{
			self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::HOLD_FRAME);
			
			if (self.e.s.frame == soldier::frames::attak303)
				self.monsterinfo.nextframe = soldier::frames::attak306;
		}
		else
			self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags | ai_flags_t::HOLD_FRAME);
	}
}

// ATTACK1 (blaster/shotgun)

void soldier_fire1(ASEntity &self)
{
	soldier_fire(self, 0, false);
}

void soldier_attack1_refire1(ASEntity &self)
{
	soldier_style_t style(self);

	// [Paril-KEX]
	if (style.is_light())
		self.monsterinfo.nextframe = soldier::frames::attak110;

	// PMM - blindfire
	if ((self.monsterinfo.aiflags & ai_flags_t::MANUAL_STEERING) != 0)
	{
		self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::MANUAL_STEERING);
		return;
	}
	// pmm

	if (self.enemy is null)
		return;

	if (!style.is_light())
		return;

	if (self.enemy.health <= 0)
		return;

	if (((frandom() < 0.5f) && visible(self, self.enemy)) || (range_to(self, self.enemy) <= RANGE_MELEE))
		self.monsterinfo.nextframe = soldier::frames::attak102;
	else
		self.monsterinfo.nextframe = soldier::frames::attak110;
}

void soldier_attack1_refire2(ASEntity &self)
{
	if (self.enemy is null)
		return;
	
	if (soldier_style_t(self).is_light())
		return;

	if (self.enemy.health <= 0)
		return;

	if (((self.radius_dmg != 0 || frandom() < 0.5f) && visible(self, self.enemy)) || (range_to(self, self.enemy) <= RANGE_MELEE))
	{
		self.monsterinfo.nextframe = soldier::frames::attak102;
		self.radius_dmg = 0;
	}
}

void soldier_attack1_shotgun_check(ASEntity &self)
{
	if (self.dmg != 0)
	{
		self.monsterinfo.nextframe = soldier::frames::attak106;
		// [Paril-KEX] indicate that we should force a refire
		self.radius_dmg = 1;
	}
}

void soldier_blind_check(ASEntity &self)
{
	if ((self.monsterinfo.aiflags & ai_flags_t::MANUAL_STEERING) != 0)
	{
		vec3_t aim = self.monsterinfo.blind_fire_target - self.e.s.origin;
		self.ideal_yaw = vectoyaw(aim);
	}
}

const array<mframe_t> soldier_frames_attack1 = {
	mframe_t(ai_charge, 0, soldier_blind_check),
	mframe_t(ai_charge, 0, soldier_attack1_shotgun_check),
	mframe_t(ai_charge, 0, soldier_fire1),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_attack1_refire1),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_cock),
	mframe_t(ai_charge, 0, soldier_attack1_refire2),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge)
};
const mmove_t soldier_move_attack1 = mmove_t(soldier::frames::attak101, soldier::frames::attak112, soldier_frames_attack1, soldier_run);

// ATTACK1 (blaster/shotgun)
void soldierh_hyper_refire1(ASEntity &self)
{
	if (self.enemy is null)
		return;
	
	soldier_style_t style(self);

	if (style.has_bluehyper())
	{
		if (frandom() < 0.7f && visible(self, self.enemy))
			self.e.s.frame = soldier::frames::attak103;
	}
}

void soldierh_hyperripper1(ASEntity &self)
{
	soldier_style_t style(self);

	if (!style.is_sustain())
		soldier_fire(self, 0, false);
}

const array<mframe_t> soldierh_frames_attack1 = {
	mframe_t(ai_charge, 0, soldier_blind_check),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_start),
	mframe_t(ai_charge, 0, soldier_fire1),
	mframe_t(ai_charge, 0, soldierh_hyperripper1),
	mframe_t(ai_charge, 0, soldierh_hyperripper1),
	mframe_t(ai_charge, 0, soldier_attack1_refire1),
	mframe_t(ai_charge, 0, soldierh_hyper_refire1),
	mframe_t(ai_charge, 0, soldier_cock),
	mframe_t(ai_charge, 0, soldier_attack1_refire2),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_end),
	mframe_t(ai_charge),
	mframe_t(ai_charge)
};
const mmove_t soldierh_move_attack1 = mmove_t(soldier::frames::attak101, soldier::frames::attak112, soldierh_frames_attack1, soldier_run);

// ATTACK2 (blaster/shotgun)

void soldier_fire2(ASEntity &self)
{
	soldier_fire(self, 1, false);
}

void soldier_attack2_refire1(ASEntity &self)
{
	soldier_style_t style(self);

	if (style.is_light())
		self.monsterinfo.nextframe = soldier::frames::attak216;

	if (self.enemy is null)
		return;

	if (!style.is_light())
		return;

	if (self.enemy.health <= 0)
		return;

	if (((frandom() < 0.5f) && visible(self, self.enemy)) || (range_to(self, self.enemy) <= RANGE_MELEE))
		self.monsterinfo.nextframe = soldier::frames::attak204;
}

void soldier_attack2_refire2(ASEntity &self)
{
	if (self.enemy is null)
		return;
	
	soldier_style_t style(self);

	if (style.is_light())
		return;

	if (self.enemy.health <= 0)
		return;

	// RAFAEL
	if (
		((self.radius_dmg != 0 || frandom() < 0.5f) && visible(self, self.enemy)) ||
		range_to(self, self.enemy) <= RANGE_MELEE
	)
	{
		// RAFAEL
		self.monsterinfo.nextframe = soldier::frames::attak204;
		self.radius_dmg = 0;
	}
}

void soldier_attack2_shotgun_check(ASEntity &self)
{
	if (self.dmg != 0)
	{
		self.monsterinfo.nextframe = soldier::frames::attak210;
		// [Paril-KEX] indicate that we should force a refire
		self.radius_dmg = 1;
	}
}

const array<mframe_t> soldier_frames_attack2 = {
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_attack2_shotgun_check),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_fire2),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_attack2_refire1),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_cock),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_attack2_refire2),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge)
};
const mmove_t soldier_move_attack2 = mmove_t(soldier::frames::attak201, soldier::frames::attak218, soldier_frames_attack2, soldier_run);

// RAFAEL
void soldierh_hyper_refire2(ASEntity &self)
{
	if (self.enemy is null)
		return;

	if (soldier_style_t(self).is_blitz())
	{
		if (frandom() < 0.7f && visible(self, self.enemy))
			self.e.s.frame = soldier::frames::attak205;
	}
}

void soldierh_hyperripper2(ASEntity &self)
{
	soldier_style_t style(self);

	if (!style.is_sustain())
		soldier_fire(self, 1, false);
}

const array<mframe_t> soldierh_frames_attack2 = {
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_start),
	mframe_t(ai_charge, 0, soldier_fire2),
	mframe_t(ai_charge, 0, soldierh_hyperripper2),
	mframe_t(ai_charge, 0, soldierh_hyperripper2),
	mframe_t(ai_charge, 0, soldier_attack2_refire1),
	mframe_t(ai_charge, 0, soldierh_hyper_refire2),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_cock),
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldier_attack2_refire2),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_end),
	mframe_t(ai_charge),
	mframe_t(ai_charge)
};
const mmove_t soldierh_move_attack2 = mmove_t(soldier::frames::attak201, soldier::frames::attak218, soldierh_frames_attack2, soldier_run);
// RAFAEL

// ATTACK3 (duck and shoot)
void soldier_fire3(ASEntity &self)
{
	soldier_fire(self, 2, false);
}

void soldierh_hyperripper3(ASEntity &self)
{
	soldier_style_t style(self);

	if (style.has_ripper() || style.has_bluehyper())
		soldier_fire(self, 2, false);
}

void soldier_attack3_refire(ASEntity &self)
{
	if (self.dmg != 0)
		monster_duck_hold(self);
	else if ((level.time + time_ms(400)) < self.monsterinfo.duck_wait_time)
		self.monsterinfo.nextframe = soldier::frames::attak303;
}

const array<mframe_t> soldier_frames_attack3 = {
	mframe_t(ai_charge, 0, monster_duck_down),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_start),
	mframe_t(ai_charge, 0, soldier_fire3),
	mframe_t(ai_charge, 0, soldierh_hyperripper3),
	mframe_t(ai_charge, 0, soldierh_hyperripper3),
	mframe_t(ai_charge, 0, soldier_attack3_refire),
	mframe_t(ai_charge, 0, monster_duck_up),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_end),
	mframe_t(ai_charge)
};
const mmove_t soldier_move_attack3 = mmove_t(soldier::frames::attak301, soldier::frames::attak309, soldier_frames_attack3, soldier_run);

// ATTACK4 (machinegun)

void soldier_fire4(ASEntity &self)
{
	soldier_fire(self, 3, false);
}

const array<mframe_t> soldier_frames_attack4 = {
	mframe_t(ai_charge),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_start),
	mframe_t(ai_charge, 0, soldier_fire4),
	mframe_t(ai_charge, 0, soldierh_hyper_sound_end),
	mframe_t(ai_charge),
	mframe_t(ai_charge)
};
const mmove_t soldier_move_attack4 = mmove_t(soldier::frames::attak401, soldier::frames::attak406, soldier_frames_attack4, soldier_run);

// ATTACK6 (run & shoot)

void soldier_fire8(ASEntity &self)
{
	soldier_fire(self, 7, true);
}

void soldier_attack6_refire1(ASEntity &self)
{
	// PMM - make sure dodge & charge bits are cleared
	monster_done_dodge(self);
	soldier_stop_charge(self);

	if (self.enemy is null)
		return;
	
	soldier_style_t style(self);

	if (!style.is_light())
		return;

	if (self.enemy.health <= 0 ||
		range_to(self, self.enemy) < RANGE_NEAR ||
		!visible(self, self.enemy)) // don't endlessly run into walls
	{
		soldier_run(self);
		return;
	}

	if (frandom() < 0.25f)
		self.monsterinfo.nextframe = soldier::frames::runs03;
	else
		soldier_run(self);
}

void soldier_attack6_refire2(ASEntity &self)
{
	// PMM - make sure dodge & charge bits are cleared
	monster_done_dodge(self);
	soldier_stop_charge(self);
	
	soldier_style_t style(self);

	if (self.enemy is null || style.is_light())
		return;

	if (self.enemy.health <= 0 ||
		(self.radius_dmg == 0 && range_to(self, self.enemy) < RANGE_NEAR) ||
		!visible(self, self.enemy)) // don't endlessly run into walls
	{
		soldierh_hyper_sound_end(self);
		return;
	}

	if (self.radius_dmg != 0 || frandom() < 0.25f)
	{
		self.monsterinfo.nextframe = soldier::frames::runs03;
		self.radius_dmg = 0;
	}
}

void soldier_attack6_shotgun_check(ASEntity &self)
{
	soldier_style_t style(self);

	if (self.dmg != 0)
	{
		self.monsterinfo.nextframe = soldier::frames::runs09;
		// [Paril-KEX] indicate that we should force a refire
		self.radius_dmg = 1;
	}
	// [Paril-KEX] don't let the shotgun guard fire immediately.
	else if (style.has_shotgun())
	{
		if (self.sounds == 0)
		{
			self.sounds = 1;
			self.radius_dmg = 1;
			self.monsterinfo.nextframe = soldier::frames::runs09;
		}
	}
}

void soldierh_hyperripper8(ASEntity &self)
{
	soldier_style_t style(self);

	if (style.has_ripper() || style.has_bluehyper())
		soldier_fire(self, 7, true);
}

const array<mframe_t> soldier_frames_attack6 = {
	mframe_t(ai_run, 10, soldier_start_charge),
	mframe_t(ai_run, 4, soldier_attack6_shotgun_check),
	mframe_t(ai_run, 12, soldierh_hyper_sound_start),
	mframe_t(ai_run, 11, function(self) { soldier_fire8(self); monster_footstep(self); }),
	mframe_t(ai_run, 13, function(self) { soldierh_hyperripper8(self); monster_done_dodge(self); }),
	mframe_t(ai_run, 18, soldierh_hyperripper8),
	mframe_t(ai_run, 15, monster_footstep),
	mframe_t(ai_run, 14, soldier_attack6_refire1),
	mframe_t(ai_run, 11),
	mframe_t(ai_run, 8, monster_footstep),
	mframe_t(ai_run, 11, soldier_cock),
	mframe_t(ai_run, 12),
	mframe_t(ai_run, 12, monster_footstep),
	mframe_t(ai_run, 17, soldier_attack6_refire2)
};
const mmove_t soldier_move_attack6 = mmove_t(soldier::frames::runs01, soldier::frames::runs14, soldier_frames_attack6, soldier_run, 0.65f);

void soldier_attack(ASEntity &self)
{
	float r, chance;

	monster_done_dodge(self);

	soldier_style_t style(self);

	// PMM - blindfire!
	if (self.monsterinfo.attack_state == ai_attack_state_t::BLIND)
	{
		// setup shot probabilities
		if (self.monsterinfo.blind_fire_delay < time_sec(1))
			chance = 1.0f;
		else if (self.monsterinfo.blind_fire_delay < time_sec(7.5))
			chance = 0.4f;
		else
			chance = 0.1f;

		r = frandom();

		// minimum of 4.1 seconds, plus 0-3, after the shots are done
		self.monsterinfo.blind_fire_delay += time_sec(4.1) + random_time(time_sec(3));

		// don't shoot at the origin
		if (!self.monsterinfo.blind_fire_target)
			return;

		// don't shoot if the dice say not to
		if (r > chance)
			return;

		// turn on manual steering to signal both manual steering and blindfire
		self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags | ai_flags_t::MANUAL_STEERING);

		// RAFAEL
		if (style.is_xatrix())
			M_SetAnimation(self, soldierh_move_attack1);
		else
		// RAFAEL
			M_SetAnimation(self, soldier_move_attack1);
		self.monsterinfo.attack_finished = level.time + random_time(time_sec(1.5), time_sec(2.5));
		return;
	}
	// pmm

	// PMM - added this so the soldiers now run toward you and shoot instead of just stopping and shooting
	r = frandom();

	// nb: run-shoot not limited by `M_CheckClearShot` since they will be far enough
	// away that it doesn't matter

	if (((self.monsterinfo.aiflags & (ai_flags_t::BLOCKED | ai_flags_t::STAND_GROUND)) == 0) &&
		(r < 0.25f &&
		(style.is_light() || style.is_blitz())) &&
		(range_to(self, self.enemy) >= (RANGE_NEAR * 0.5f)))
	{
		// [Paril-KEX] 
		M_SetAnimation(self, soldier_move_attack6);
		self.sounds = 0;
	}
	else
	{
		if (style.is_light() || style.is_blitz())
		{
			bool attack1_possible = false;

			// [Paril-KEX] shotgun guard only uses attack2 at close range
			if (!style.has_shotgun() || range_to(self, self.enemy) > (RANGE_NEAR * 0.65f))
				attack1_possible = M_CheckClearShot(self, monster_flash_offset[monster_muzzle_t::SOLDIER_BLASTER_1]);
			
			bool attack2_possible = M_CheckClearShot(self, monster_flash_offset[monster_muzzle_t::SOLDIER_BLASTER_2]);

			if (attack1_possible && (!attack2_possible || frandom() < 0.5f))
			{
				// RAFAEL
				if (style.is_xatrix())
					M_SetAnimation(self, soldierh_move_attack1);
				else
					// RAFAEL
					M_SetAnimation(self, soldier_move_attack1);
			}
			else if (attack2_possible)
			{
				// RAFAEL
				if (style.is_xatrix())
					M_SetAnimation(self, soldierh_move_attack2);
				else
					// RAFAEL
					M_SetAnimation(self, soldier_move_attack2);
			}
		}
		else if (M_CheckClearShot(self, monster_flash_offset[monster_muzzle_t::SOLDIER_MACHINEGUN_4]))
		{
			M_SetAnimation(self, soldier_move_attack4);
		}
	}
}

//
// SIGHT
//

void soldier_sight(ASEntity &self, ASEntity &other)
{
	if (frandom() < 0.5f)
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::sight1, 1, ATTN_NORM, 0);
	else
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::sight2, 1, ATTN_NORM, 0);

	soldier_style_t style(self);

	if (self.enemy !is null &&
		(range_to(self, self.enemy) >= RANGE_NEAR) &&
		visible(self, self.enemy) // Paril: don't run-shoot if we can't see them
	)
	{
		// RAFAEL
		if (style.is_xatrix() || frandom() > 0.75f)
		// RAFAEL
		{
			if (!style.is_sustain())
			{
				M_SetAnimation(self, soldier_move_attack6);
				self.sounds = 0;
			}
		}
	}
}

//
// DUCK
//
const array<mframe_t> soldier_frames_duck = {
	mframe_t(ai_move, 5, monster_duck_down),
	mframe_t(ai_move, -1, monster_duck_hold),
	mframe_t(ai_move, 1),
	mframe_t(ai_move, 0, monster_duck_up),
	mframe_t(ai_move, 5)
};
const mmove_t soldier_move_duck = mmove_t(soldier::frames::duck01, soldier::frames::duck05, soldier_frames_duck, soldier_run);

void soldier_stand_up(ASEntity &self)
{
	soldierh_hyper_sound_end(self);
	M_SetAnimation(self, soldier_move_trip, false);
	self.monsterinfo.nextframe = soldier::frames::runt08;
}

bool soldier_prone_shoot_ok(ASEntity &self)
{
	if (self.enemy is null || !self.enemy.e.inuse)
		return false;

	vec3_t fwd;
	AngleVectors(self.e.s.angles, fwd);

	vec3_t diff = self.enemy.e.s.origin - self.e.s.origin;
	diff.z = 0;
	diff.normalize();

	float v = fwd.dot(diff);

	if (v < 0.80f)
		return false;
	
	return true;
}

void ai_soldier_move(ASEntity &self, float dist)
{
	ai_move(self, dist);

	if (!soldier_prone_shoot_ok(self))
	{
		soldier_stand_up(self);
		return;
	}
}

void soldier_fire5(ASEntity &self)
{
	soldier_fire(self, 8, true);
}

void soldierh_hyperripper5(ASEntity &self)
{
	soldier_style_t style(self);

	if (style.has_ripper() || style.has_bluehyper())
		soldier_fire(self, 8, true);
}

const array<mframe_t> soldier_frames_attack5 = {
	mframe_t(ai_move, 18, monster_duck_down),
	mframe_t(ai_move, 11, monster_footstep),
	mframe_t(ai_move, 0, monster_footstep),
	mframe_t(ai_soldier_move),
	mframe_t(ai_soldier_move, 0, soldierh_hyper_sound_start),
	mframe_t(ai_soldier_move, 0, soldier_fire5),
	mframe_t(ai_soldier_move, 0, soldierh_hyperripper5),
	mframe_t(ai_soldier_move, 0, soldierh_hyperripper5),
};
const mmove_t soldier_move_attack5 = mmove_t(soldier::frames::attak501, soldier::frames::attak508, soldier_frames_attack5, soldier_stand_up);

void monster_check_prone(ASEntity &self)
{
	soldier_style_t style(self);

	// we're a shotgun guard waiting to cock
	if (style.has_shotgun() && self.dmg != 0)
		return;

	// not going to shoot at this angle
	if (!soldier_prone_shoot_ok(self))
		return;

	M_SetAnimation(self, soldier_move_attack5, false);
}

const array<mframe_t> soldier_frames_trip = {
	mframe_t(ai_move, 10),
	mframe_t(ai_move, 2, monster_check_prone),
	mframe_t(ai_move, 18, monster_duck_down),
	mframe_t(ai_move, 11, monster_footstep),
	mframe_t(ai_move, 9),
	mframe_t(ai_move, -11, monster_footstep),
	mframe_t(ai_move, -2),
	mframe_t(ai_move, 0),
	mframe_t(ai_move, 6),
	mframe_t(ai_move, -5),
	mframe_t(ai_move, 0),
	mframe_t(ai_move, 1),
	mframe_t(ai_move, 0, monster_footstep),
	mframe_t(ai_move, 0, monster_duck_up),
	mframe_t(ai_move, 3),
	mframe_t(ai_move, 2, monster_footstep),
	mframe_t(ai_move, -1),
	mframe_t(ai_move, 2),
	mframe_t(ai_move, 0),
};
const mmove_t soldier_move_trip = mmove_t(soldier::frames::runt01, soldier::frames::runt19, soldier_frames_trip, soldier_run);

// pmm - blocking code

bool soldier_blocked(ASEntity &self, float dist)
{
	// don't do anything if you're dodging
	if ((self.monsterinfo.aiflags & ai_flags_t::DODGING) != 0 || (self.monsterinfo.aiflags & ai_flags_t::DUCKED) != 0)
		return false;

	return blocked_checkplat(self, dist);
}

//
// DEATH
//

void soldier_fire6(ASEntity &self)
{
	soldier_fire(self, 5, false);

	if (self.dmg != 0)
		self.monsterinfo.nextframe = soldier::frames::death126;
}

void soldier_fire7(ASEntity &self)
{
	soldier_fire(self, 6, false);
}

void soldier_dead(ASEntity &self)
{
	self.e.mins = { -16, -16, -24 };
	self.e.maxs = { 16, 16, -8 };
	monster_dead(self);
}

void soldier_death_shrink(ASEntity &self)
{
	self.e.svflags = svflags_t(self.e.svflags | svflags_t::DEADMONSTER);
	self.e.maxs[2] = 0;
	gi_linkentity(self.e);
}

const array<mframe_t> soldier_frames_death1 = {
	mframe_t(ai_move),
	mframe_t(ai_move, -10),
	mframe_t(ai_move, -10),
	mframe_t(ai_move, -10, soldier_death_shrink),
	mframe_t(ai_move, -5),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move, 0, soldierh_hyper_sound_start),
	mframe_t(ai_move, 0, soldier_fire6),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, 0, soldier_fire7),
	mframe_t(ai_move, 0, soldierh_hyper_sound_end),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move)
};
const mmove_t soldier_move_death1 = mmove_t(soldier::frames::death101, soldier::frames::death136, soldier_frames_death1, soldier_dead);

const array<mframe_t> soldier_frames_death2 = {
	mframe_t(ai_move, -5),
	mframe_t(ai_move, -5),
	mframe_t(ai_move, -5),
	mframe_t(ai_move, 0, soldier_death_shrink),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move)
};
const mmove_t soldier_move_death2 = mmove_t(soldier::frames::death201, soldier::frames::death235, soldier_frames_death2, soldier_dead);

const array<mframe_t> soldier_frames_death3 = {
	mframe_t(ai_move, -5),
	mframe_t(ai_move, -5),
	mframe_t(ai_move, -5),
	mframe_t(ai_move, 0, soldier_death_shrink),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
};
const mmove_t soldier_move_death3 = mmove_t(soldier::frames::death301, soldier::frames::death345, soldier_frames_death3, soldier_dead);

const array<mframe_t> soldier_frames_death4 = {
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, 1.5f),
	mframe_t(ai_move, 2.5f),
	mframe_t(ai_move, -1.5f),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, -0.5f),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move, 4.0f),
	mframe_t(ai_move, 4.0f),
	mframe_t(ai_move, 8.0f, soldier_death_shrink),
	mframe_t(ai_move, 8.0f),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, 5.5f),

	mframe_t(ai_move, 2.5f),
	mframe_t(ai_move, -2.0f),
	mframe_t(ai_move, -2.0f)
};
const mmove_t soldier_move_death4 = mmove_t(soldier::frames::death401, soldier::frames::death453, soldier_frames_death4, soldier_dead);

const array<mframe_t> soldier_frames_death5 = {
	mframe_t(ai_move, -5),
	mframe_t(ai_move, -5),
	mframe_t(ai_move, -5),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, 0, soldier_death_shrink),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move)
};
const mmove_t soldier_move_death5 = mmove_t(soldier::frames::death501, soldier::frames::death524, soldier_frames_death5, soldier_dead);

const array<mframe_t> soldier_frames_death6 = {
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move, 0, soldier_death_shrink),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move)
};
const mmove_t soldier_move_death6 = mmove_t(soldier::frames::death601, soldier::frames::death610, soldier_frames_death6, soldier_dead);

void soldier_die(ASEntity &self, ASEntity &inflictor, ASEntity &attacker, int damage, const vec3_t &in point, const mod_t &in mod)
{
	int n;

	soldierh_hyper_sound_end(self);

	// check for gib
	if (M_CheckGib(self, mod))
	{
		gi_sound(self.e, soundchan_t::VOICE, gi_soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);

		self.e.s.skinnum /= 2;

		if (self.beam !is null)
		{
			G_FreeEdict(self.beam);
			@self.beam = null;
		}

		ThrowGibs(self, damage, {
			gib_def_t(3, "models/objects/gibs/sm_meat/tris.md2"),
			gib_def_t("models/objects/gibs/bone2/tris.md2"),
			gib_def_t("models/objects/gibs/bone/tris.md2"),
			gib_def_t("models/monsters/soldier/gibs/arm.md2", gib_type_t::SKINNED),
			gib_def_t("models/monsters/soldier/gibs/gun.md2", gib_type_t(gib_type_t::SKINNED | gib_type_t::UPRIGHT)),
			gib_def_t("models/monsters/soldier/gibs/chest.md2", gib_type_t::SKINNED),
			gib_def_t("models/monsters/soldier/gibs/head.md2", gib_type_t(gib_type_t::HEAD | gib_type_t::SKINNED))
		});
		self.deadflag = true;
		return;
	}

	if (self.deadflag)
		return;

	// regular death
	self.deadflag = true;
	self.takedamage = true;
	
	soldier_style_t style(self);

	if (style.is_light())
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::death_light, 1, ATTN_NORM, 0);
	else if (style.is_blitz())
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::death, 1, ATTN_NORM, 0);
	else
		gi_sound(self.e, soundchan_t::VOICE, soldier::sounds::death_ss, 1, ATTN_NORM, 0);

	if (abs((self.e.s.origin[2] + self.viewheight) - point[2]) <= 4 &&
		self.velocity.z < 65.0f)
	{
		// head shot
		M_SetAnimation(self, soldier_move_death3);
		return;
	}

	// if we die while on the ground, do a quicker death4
	if (self.monsterinfo.active_move is soldier_move_trip ||
		self.monsterinfo.active_move is soldier_move_attack5)
	{
		M_SetAnimation(self, soldier_move_death4);
		self.monsterinfo.nextframe = soldier::frames::death413;
		soldier_death_shrink(self);
		return;
	}

	// only do the spin-death if we have enough velocity to justify it
	if (self.velocity.z > 65.0f || self.velocity.length() > 150.0f)
		n = irandom(5);
	else
		n = irandom(4);

	if (n == 0)
		M_SetAnimation(self, soldier_move_death1);
	else if (n == 1)
		M_SetAnimation(self, soldier_move_death2);
	else if (n == 2)
		M_SetAnimation(self, soldier_move_death4);
	else if (n == 3)
		M_SetAnimation(self, soldier_move_death5);
	else
		M_SetAnimation(self, soldier_move_death6);
}

//
// NEW DODGE CODE
//

bool soldier_sidestep(ASEntity &self)
{
	// don't sidestep during trip or up pain
	if (self.monsterinfo.active_move is soldier_move_trip ||
		self.monsterinfo.active_move is soldier_move_attack5 ||
		self.monsterinfo.active_move is soldier_move_pain4)
		return false;

	soldier_style_t style(self);

	if (!style.is_sustain())
	{
		if (self.monsterinfo.active_move !is soldier_move_attack6)
		{
			M_SetAnimation(self, soldier_move_attack6);
			self.sounds = 0;
			soldierh_hyper_sound_end(self);
		}
	}
	else
	{
		if (self.monsterinfo.active_move !is soldier_move_start_run &&
			self.monsterinfo.active_move !is soldier_move_run)
		{
			M_SetAnimation(self, soldier_move_start_run);
			soldierh_hyper_sound_end(self);
			soldier_stop_charge(self);
		}
	}

	return true;
}

bool soldier_duck(ASEntity &self, gtime_t eta)
{
	self.monsterinfo.aiflags = ai_flags_t(self.monsterinfo.aiflags & ~ai_flags_t::HOLD_FRAME);
	soldier_stop_charge(self);

	soldier_style_t style(self);

	if (self.monsterinfo.active_move is soldier_move_attack6)
	{
		M_SetAnimation(self, soldier_move_trip);
	}
	else if (self.dmg != 0 ||
		(style.is_sustain() ? (frandom() > 0.50f + (skill.integer * 0.12f)) : brandom()))
	{
		M_SetAnimation(self, soldier_move_duck);
	}
	else
	{
		M_SetAnimation(self, soldier_move_attack3);
	}

	soldierh_hyper_sound_end(self);
	return true;
}

//=========
// ROGUE
const array<mframe_t> soldier_frames_blind = {
	mframe_t(ai_move, 0, soldier_idle),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),

	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move),
	mframe_t(ai_move)
};
const mmove_t soldier_move_blind = mmove_t(soldier::frames::stand101, soldier::frames::stand130, soldier_frames_blind, soldier_blind);

void soldier_blind(ASEntity &self)
{
	M_SetAnimation(self, soldier_move_blind);
}
// ROGUE
//=========

//
// SPAWN
//

namespace spawnflags::soldier
{
    const uint32 BLIND = 8;
}

void SP_monster_soldier_x(ASEntity &self)
{
	self.e.s.modelindex = gi_modelindex("models/monsters/soldier/tris.md2");
	self.monsterinfo.scale = soldier::SCALE;
	self.e.mins = { -16, -16, -24 };
	self.e.maxs = { 16, 16, 32 };
	self.movetype = movetype_t::STEP;
	self.e.solid = solid_t::BBOX;

	soldier::sounds::idle.precache();
	soldier::sounds::sight1.precache();
	soldier::sounds::sight2.precache();
	soldier::sounds::cock.precache();
	
	gi_modelindex("models/monsters/soldier/gibs/head.md2");
	gi_modelindex("models/monsters/soldier/gibs/gun.md2");
	gi_modelindex("models/monsters/soldier/gibs/arm.md2");
	gi_modelindex("models/monsters/soldier/gibs/chest.md2");

	self.mass = 100;

	@self.pain = soldier_pain;
	@self.die = soldier_die;

	@self.monsterinfo.stand = soldier_stand;
	@self.monsterinfo.walk = soldier_walk;
	@self.monsterinfo.run = soldier_run;
	@self.monsterinfo.dodge = M_MonsterDodge;
	@self.monsterinfo.attack = soldier_attack;
	@self.monsterinfo.melee = null;
	@self.monsterinfo.sight = soldier_sight;
	@self.monsterinfo.setskin = soldier_setskin;

	//=====
	// ROGUE
	@self.monsterinfo.blocked = soldier_blocked;
	@self.monsterinfo.duck = soldier_duck;
	@self.monsterinfo.unduck = monster_duck_up;
	@self.monsterinfo.sidestep = soldier_sidestep;

	if ((self.spawnflags & spawnflags::soldier::BLIND) != 0) // blind
		@self.monsterinfo.stand = soldier_blind;
	// ROGUE
	//=====

	gi_linkentity(self.e);

	self.monsterinfo.stand(self);

	walkmonster_start(self);
}

/*QUAKED monster_soldier_light (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
 */
void SP_monster_soldier_light(ASEntity &self)
{
	const spawn_temp_t @st = ED_GetSpawnTemp();

	if ( !M_AllowSpawn( self ) ) {
		G_FreeEdict( self );
		return;
	}

	SP_monster_soldier_x(self);

	soldier::sounds::pain_light.precache();
	soldier::sounds::death_light.precache();
	gi_modelindex("models/objects/laser/tris.md2");
	gi_soundindex("misc/lasfly.wav");
	gi_soundindex("soldier/solatck2.wav");

	self.e.s.skinnum = 0;
	self.count = self.e.s.skinnum;
	self.health = self.max_health = int(20 * st.health_multiplier);
	self.gib_health = -30;

	// PMM - blindfire
	self.monsterinfo.blindfire = true;
}

/*QUAKED monster_soldier (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
 */
void SP_monster_soldier(ASEntity &self)
{
	const spawn_temp_t @st = ED_GetSpawnTemp();

	if( !M_AllowSpawn( self ) ) {
		G_FreeEdict( self );
		return;
	}

	SP_monster_soldier_x(self);

	soldier::sounds::pain.precache();
	soldier::sounds::death.precache();
	gi_soundindex("soldier/solatck1.wav");

	self.e.s.skinnum = 2;
	self.count = self.e.s.skinnum;
	self.health = self.max_health = int(30 * st.health_multiplier);
	self.gib_health = -30;
}

/*QUAKED monster_soldier_ss (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
 */
void SP_monster_soldier_ss(ASEntity &self)
{
	const spawn_temp_t @st = ED_GetSpawnTemp();

	if ( !M_AllowSpawn( self ) ) {
		G_FreeEdict( self );
		return;
	}

	SP_monster_soldier_x(self);

	soldier::sounds::pain_ss.precache();
	soldier::sounds::death_ss.precache();
	gi_soundindex("soldier/solatck3.wav");

	self.e.s.skinnum = 4;
	self.count = self.e.s.skinnum;
	self.health = self.max_health = int(40 * st.health_multiplier);
	self.gib_health = -30;
}

//
// SPAWN
//

void SP_monster_soldier_h(ASEntity &self)
{
	SP_monster_soldier_x(self);
	self.style = 1;
}

/*QUAKED monster_soldier_ripper (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
 */
void SP_monster_soldier_ripper(ASEntity &self)
{
	const spawn_temp_t @st = ED_GetSpawnTemp();

	if ( !M_AllowSpawn( self ) ) {
		G_FreeEdict( self );
		return;
	}

	SP_monster_soldier_h(self);

	soldier::sounds::pain_light.precache();
	soldier::sounds::death_light.precache();
	gi_modelindex("models/objects/boomrang/tris.md2");
	gi_soundindex("misc/lasfly.wav");
	gi_soundindex("soldier/solatck2.wav");

	self.e.s.skinnum = 6;
	self.count = self.e.s.skinnum - 6;
	self.health = self.max_health = int(50 * st.health_multiplier);
	self.gib_health = -30;

	// PMM - blindfire
	self.monsterinfo.blindfire = true;
}

/*QUAKED monster_soldier_hypergun (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
 */
void SP_monster_soldier_hypergun(ASEntity &self)
{
	const spawn_temp_t @st = ED_GetSpawnTemp();

	if ( !M_AllowSpawn( self ) ) {
		G_FreeEdict( self );
		return;
	}

	SP_monster_soldier_h(self);

	gi_modelindex("models/objects/laser/tris.md2");
	soldier::sounds::pain.precache();
	soldier::sounds::death.precache();
	gi_soundindex("soldier/solatck1.wav");
	gi_soundindex("weapons/hyprbd1a.wav");
	gi_soundindex("weapons/hyprbl1a.wav");

	self.e.s.skinnum = 8;
	self.count = self.e.s.skinnum - 6;
	self.health = self.max_health = int(60 * st.health_multiplier);
	self.gib_health = -30;

	// PMM - blindfire
	self.monsterinfo.blindfire = true;
}

/*QUAKED monster_soldier_lasergun (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
 */
void SP_monster_soldier_lasergun(ASEntity &self)
{
	const spawn_temp_t @st = ED_GetSpawnTemp();

	if ( !M_AllowSpawn( self ) ) {
		G_FreeEdict( self );
		return;
	}

	SP_monster_soldier_h(self);

	soldier::sounds::pain_ss.precache();
	soldier::sounds::death_ss.precache();
	gi_soundindex("soldier/solatck3.wav");

	self.e.s.skinnum = 10;
	self.count = self.e.s.skinnum - 6;
	self.health = self.max_health = int(70 * st.health_multiplier);
	self.gib_health = -30;
}

// END 13-APR-98
