Most notable differences from programming for Quake II re-release (C++):
* no manual memory management is required; strings, for instance, are value types, and AS handles garbage collection of other types of objects.
* currently no way of doing custom value types (AngelScript only natively supports making ref types)
* entities in AS-land are wrapped around a custom type (ASEntity). The type it wraps (edict_t) is a handle owned by native. A side effect of this is that ASEntity contains the game-specific data, and the handle (the `e` member) contains the data that is communicated between native and script. Where you'd once do `ent->s.origin`, you must now do `ent.e.s.origin`, as s.origin is a part of the handle, not the entity.
* gclient_t is also a handle, and can be accessed one of two ways - either via edict_t::client (eg ent.e.client), or directly on the entity client object (eg ent.client.c). 
* the player state (player_state_t in Q2 land) can be accessed three ways in script land; the two methods above work, but you can also directly access the player_state_t on entity handles (eg, ent.e.ps points to the same place as ent.e.client.ps). For obvious reasons, you'll get a null exception if you try to access this on a non-client entity.
* there are convenience duplicates registered for accessing the entity_state_t properties without `s`; eg, `ent.e.origin` is the same as `ent.e.s.origin`.
* there are convenience duplicates registered for accessing player_state_t properties without `ps` (eg `ent.e.client.ps.stats` / `ent.client.c.ps.stats` can be accessed via `ent.e.client.stats` / `ent.client.c.stats` respectively).
* spawn functions work more similarly to QuakeC; you no longer need to actually set them in any sort of spawnables array, it will just search the script for a function named `SP_classname` (where classname is the classname of the entity) and execute it.
* the save/load code is a bit of a mess right now, but similar to the C++ version, you still have to make sure you manually save and load the members you want to save and load.
* currently, script types are using the default ref mode of AngelScript 2.x; for a type of `T@`, `x = y` will do a value-assign and `@x = y` will do a handle-assign (a pointer change). I might change this later if a better method presents itself, since value-assigns are still useful in some contexts, just not for ASEntity and ASClient, which is where it's easy to make a mistake. I have ideas on how to prevent this from being done accidentally, though.
* byval inout is not supported currently (unlike C++, there's no way to make an `int &p` parameter for instance. you can either have an in ref or out ref, but not both).
* all enums have been turned into their own type *or* namespace; right now, there's no way to make enums that aren't 32-bit, so any 8/16/64-bit enums are currently using namespaces instead of actual enums. Hopefully in the future, these will all be made type-safe.
* COM_Parse is very expensive to do in script-land because of the overhead of strings; a new tokenizer type is available that should fit the needs without much overhead.
* The math stuff (vec3, etc) is all handled by the host. I was hoping not to have to do that but it was faster to do native calls for them. You can always implement your own math stuff if there's operations missing that you need.
* For some reason, assignments to funcdefs must use handle-assign. I don't really know why, but I assume it has something to do with its nullability or maybe delegates.

Notable differences/help for those coming from QuakeC:
* This is the full Quake II DLL in AngelScript. You have total control from AS-land in how entities work and are set up each frame.
* AngelScript has a concept of value types vs ref types. It's hard to boil down all of the differences here, but here's some tips that you can apply when trying to translate QuakeC type knowledge over to AS:
- Value types are (generally) small types that are stack-allocated, similar to C/C++. For instance, a `vec3_t` variable is going to take up 12 bytes on the stack to store all three floats, rather than storing a pointer to 3 floats stored elsewhere - vec3_t is the same as QuakeC's vector, so this should be a familiar concept already. Where things get different is for other types, such as ASEntity, array, and string. At some point I will have the full built-in library documented; most of it is in `as.predefined` but I haven't been keeping it up to date near the end.
- Ref types are handle types that can be passed around as pointers, and are more optimal for larger types or types that can be taken safe references to. All script declared types are ref types, and there is no way to create custom value types unfortunately.
- Value types can be passed to functions by value (`T value`), as an input reference (`T &in value`) or an output reference (`T &out value`). These work almost identically to how they function in QuakeC, with the exception that &in parameters can sometimes be optimized to directly reference a value if the compiler is sure that the reference location will always be safe. In general, you want to pass the larger types by in-ref whenever possible (especially string). Currently in AS, value types cannot be passed by inout; the only way to mimic this is to have a separate &in and &out parameters.
- Ref types similarly can also be passed by value, in ref or out ref like value types, however references to ref types are much cheaper. You can also pass ref types as `inout` (this can be typed as either `T &v` or `T &inout v`), which is semantically similar to a C++ reference: it points to an existing non-null object.
- Finally, there is the concept of handles; these are semantically closer to pointers in C++. You can only have handles to ref types, and they can be null. Handles are declared with the `@` modifier after the type name; for instance, `ASEntity@` is a handle to an entity which may be null. They're slightly rarer in this codebase, but there are a few places where handles are unavoidable, such as returning an entity from a function (since you cannot return a reference from a function in most cases).
- "is" and "!is" are used to check for whether a handle is or is not the same reference as another handle (or null). Doing == or != will try to do value equality.
- Syntax-wise, using a handle variable will act as if it is a reference; that is to say, for `T @h`, performing operations on `h` will dereference and perform the action on the underlying value. If you want to change *where* the handle points to, you must prefix the variable name with @ (eg, `@h = Spawn()` will assign the pointer to the same reference returned by Spawn() instead of trying to do a value-copy on it). This is a really confusing quirk of AngelScript, and unfortunately there's currently no way to change this without negatively affecting other things (there would be no way to do a value-assign if "always treat assignments as handles" was enabled, for instance). The main thing you need to watch for is using `=` on ASEntity and ASClient, as this can cause really weird things to happen.
- Strings are value types. When making a function accept strings, you should always default to declaring them as `const string &in`, and only changing this if you are trying to do non-const behaviors on them. This is because with `const string &in`, static strings can be passed directly by reference and not perform a copy.
- Strings are fully dynamic, and most functions that are print-like can take varargs and do type-based formatting. These functions (such as format, gi_ComPrint, etc) wrap fmtlib, meaning you have access to the full range of fmtlib formatting for built-in types. Eventually, I plan to allow custom types to register formatters on the script side, but for now you can just compose your own.
- Arrays are reference types. You can pass these around by handle or reference. The main downside with the `array<T>` type is that accessing individual elements has overhead. There are some specialized array value types registered that can be used situationally, but are mostly there to wrap native types that need value arrays.
* Save/load property serialization is not automatic - you have to choose what to save and make sure any new properties you add that actually need to be persisted are saved. You can check `save.as` to see how it currently works. The reason it's set up this way is to allow programmers to change the codebase to entirely OOP if they really wanted to, so a thin json document is passed to the save/load routines so they can do whatever they want with it.
* Spawn functions work identically to QuakeC with the exception that spawn function names have to be prefixed with `SP_`. Map hacks like QuakeC are technically possible, but harder to accomplish here because AngelScript has way more type checking and safety. In theory, one could actually import entirely new scripts solely via map entities, but I don't expose dynamic compilation right now.
* Entity properties (ones loaded via the map entity string) are also not dynamic, and must be specified by hand in `ED_ParseField`. It's on my list to investigate an automatic way of handling these, but I don't want to funnel people into a method that prevents them from doing crazy custom things (class-based entities, for instance).
* Entities do not link themselves in Quake II. If you change any parameter that affects world linking (mins, maxs, solid, s.origin are the only four fields I can think of offhand that will 'dirty' an entity's link state), you must call `gi_linkentity(ent.e)` to re-link the entity into the world. If the entity is not linked, it will not matter, but if you want the entity to appear properly in traces, you need to link the entity when changing any of those parameters.
* Every function from Quake's native API has an equivalent in Q2AS. Ones that were server imports (such as traceline, modelindex, etc) are prefixed with `gi_` in Quake II-land. spawn() and remove() are G_Spawn() and G_FreeEdict(), respectively.
* Global enum types are namespaced, to prevent issues with type safety (ie accidentally doing `ent.movetype = SOLID_NOT`; they're both integers so this is easy to do by accident). However, there's a few limitations that make this a bit annoying right now that I am trying to work with AngelScripts' developer on resolving:
- Enums can only be 32-bit integers, so certain enums that natively are smaller or larger (like solid_t or effects_t) are actually just raw integers with namespaced constants.
- Enums *can* be used as bitflags, but bitwise operations on enum values convert them to integer, so you have to cast the result back to the enum type.
* Currently, all wrappers to server functions that take entities or clients only take handles, and only give back handles. You may have to do an additional cast to convert them back & forth (for instance, traces will give you an `edict_t@` back, and you'll have to fetch the AngelScript object from it either via casting its as_obj or some other means; in this codebase, you can also use the `entities` array, which holds a list of the allocated ASEntity's, and will always match the entity index on the handle. That is to say, entities[0].e will always be the `edict_t@` handle with `number` 0 (the world)).
* Time in Quake II re-release is expressed in milliseconds (the smallest time unit available to us) instead of seconds. However, time is conveniently wrapped around a value type named `gtime_t`, which provides multiple ways to convert between time units. If in Quake one would do `time + 30`, in Q2AS one only needs to do `level.time + time_sec(30)` to get the same result. Time can be compared and modified via all the expected operators, and you can query units with different types (ie secondsf() or secondsi() to get seconds in float or int respectively, and milliseconds or frames() to get the results expressed in ms or number of server frames).
* Contents in Quake II are mixed; do not use == or != when trying to compare content types (like checking if a trace result is solid), use &.

Plans/other notes:
- Hot reload and debugging support are both planned but not currently implemented. You can, however, do a hot reload by performing a save followed by a load, as `load` always causes a full DLL reload (which loads all the scripts again).